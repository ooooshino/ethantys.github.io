<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ooooshino的🛖</title>
  
  <subtitle>拥抱大势的同时，也要有独立思考的自我</subtitle>
  <link href="https://oshino.cc/atom.xml" rel="self"/>
  
  <link href="https://oshino.cc/"/>
  <updated>2021-12-15T04:37:28.172Z</updated>
  <id>https://oshino.cc/</id>
  
  <author>
    <name>ooooshino</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>margin collapse &amp; BFC</title>
    <link href="https://oshino.cc/2021/10/18/margin%20collapse%20&amp;%20BFC/"/>
    <id>https://oshino.cc/2021/10/18/margin%20collapse%20&amp;%20BFC/</id>
    <published>2021-10-18T15:23:00.000Z</published>
    <updated>2021-12-15T04:37:28.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a>外边距重叠</h2><ul><li>外边距重叠（英文margin collapse，MDN 的解释如下：  块的顶部和底部边距有时合并(折叠)为单个边距，其大小是单个边距(或者是单个边距中最大的一个，如果它们相等的话)，这种行为称为边距折叠。注意，浮动和绝对定位元素的边距永远不会崩溃。</li></ul><p>这种情况并不是浏览器的bug，而是为某些情景而设计的，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;design&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam harum</span><br><span class="line">        voluptas ullam, quia veniam sunt in maiores optio laboriosam, earum</span><br><span class="line">        minus veritatis deserunt delectus repellendus eaque nostrum vitae! Amet,</span><br><span class="line">        alias.</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Lorem ipsum, dolor sit amet consectetur adipisicing elit. Necessitatibus</span><br><span class="line">        ipsam asperiores beatae facere adipisci quos nulla, officiis, fugiat</span><br><span class="line">        perspiciatis delectus temporibus aperiam a iste. Odit corporis</span><br><span class="line">        recusandae fugiat quasi tempore?</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit amet consectetur adipisicing elit. Temporibus ut</span><br><span class="line">        magni commodi accusamus eligendi amet dolorum vel, culpa facilis non.</span><br><span class="line">        Doloribus labore nemo deserunt explicabo quasi distinctio minus quo eum!</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit amet consectetur adipisicing elit. Nulla, libero</span><br><span class="line">        nisi dicta culpa perferendis et quasi, error, ullam magni ratione</span><br><span class="line">        praesentium. Iste esse ducimus voluptatum quae? Animi doloribus omnis</span><br><span class="line">        voluptas.</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d5124d8c-3dc2-4e80-bbbc-f28d0a94cd52/Untitled.png" alt="Untitled"></p><p>为了让段落分明，一般会给上margin</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">text-indent: 2em;  /* 顺便让其首行文本的缩进2个em看着舒服些 */</span><br><span class="line">    margin: 1.7em 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/742650f4-3cdb-4df1-a2d7-5668c1085509/Untitled.png" alt="Untitled"></p><p>当你打开控制台查看p标签的时候，会发现他们间隔是一样的，也就是为了这种情况而设计的，不过也产生了一种生产环境经常遇到的“bug”，叫margin collapse，也就是外边距重叠了</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/36352ede-5ef5-484a-9699-f49301c1ebcc/ezgif-4-cb26987608ab.gif" alt="ezgif-4-cb26987608ab.gif"></p><h3 id="外边距重叠的三种情况"><a href="#外边距重叠的三种情况" class="headerlink" title="外边距重叠的三种情况"></a>外边距重叠的三种情况</h3><ol><li>相邻的两个块级盒子，在第一个盒子设置了margin-bottom后第二个盒子设置了margin-top</li><li>三个层级的块盒子，最后一个层级的盒子相对于第二个层级盒子设置margin-top</li><li>三个同级对块盒子，中间对盒子内容为空，想设置margin-top和margin-bottom级来为上下两个盒子制造空隙，将发生外边距崩塌</li></ol><aside>💡 注意，会造成外边距重叠的情况，只有**垂直方向上的块级**盒子</aside><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c3b13c6-7d16-45c6-8e9a-3c53d1f04126/Untitled.png" alt="Untitled"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>子绝父相</li><li>inline-block不会造成外边距崩塌，所以可以改成inline-block(改成inline-block后要记得设置宽高)</li><li>设置pisition为relative，然后用top来代替margin-top </li><li>设置float后再来margin-top</li><li>不能设置外边距，那就改成内边距</li><li>添加边框，设置边框厚度</li><li>创建BFC（overflow:hidden会触发创建BFC）</li></ol><h2 id="BFC（block-formating-context-块级格式化上下文）"><a href="#BFC（block-formating-context-块级格式化上下文）" class="headerlink" title="BFC（block formating context 块级格式化上下文）"></a>BFC（block formating context 块级格式化上下文）</h2><p>前端的布局有三种：</p><ol><li>普通流（也是浏览器默认的）<ul><li>块级格式化上下文（BFC，block formatting context）。</li><li>内联格式化上下文（IFC，inline formatting context）。</li><li>弹性格式化上下文（FFC，flex formatting context），在 CSS3 中定义。</li><li>栅格格式化上下文（GFC，grid formatting context），在 CSS3 中定义。</li></ul></li><li>flow布局</li><li>绝对定位</li></ol><p>后两个都会脱离文档流，接下来要讲的BFC，就是属于普通流一种</p><p><strong>BFC会形成独立的渲染区域，使得内部元素的渲染不会影响到外界</strong></p><ol><li>清除浮动 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//主要代码，为了方便看到效果，给了背景色</span><br><span class="line">// rgb(228, 99, 48)</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content_box&quot;</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/selfie.jpg&quot;</span>/&gt;</span></span><br><span class="line"> // rgb(168, 218, 235)</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;statement&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure> <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5265f499-5d87-48f8-8e24-fa5d8a92eb17/Untitled.png" alt="Untitled"> 一般在情况下，都是一边产品图，一边文字说明，这里我们让图片设置为 flow（当然还有其他解决方案，这里是为了方便举例子，其他就不扩展了） <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5cdb26bc-b6a4-447d-a958-8f8277f89b3e/Untitled.png" alt="Untitled"> 可以看到flow设置为flow之后，img脱离了文档流，content_box的大小变成只靠两个p来支撑，我们需要的是content_box是img的大小也<strong>影响着</strong>content_box，这种情况下就可以给content_box的css添加<strong>一个属性来触发BFC，因为为了在此情况下不要有太大改变，一般我们使用display:flow-root或者contain:layout（加黑是因为你也可以使用其他属性来触发BFC，比如overflow:hidden)</strong> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.content_box</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7d165bb2-05c8-41a4-8f34-dd9afafdc45e/Untitled.png" alt="Untitled"> <strong>这样就可以清除掉img的 flow:left  所脱离文档流从而影响content_box的整体渲染</strong></li><li><strong>包裹浮动</strong> 还是上面👆的例子，打开控制台，元素里查看以下statement盒子 <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65c2edb5-09c6-4a75-99b9-20f01c236242/Untitled.png" alt="Untitled"> 看到这里的p标签还是占着一整行，这样在我们后面调整statement盒子使得文字不要那么贴近图片的时候是很不方便的，比如添加padding-left（ps：调整p的padding/margin也一样） <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8e833e90-0dac-4320-94ca-2f725b5e36e8/Untitled.png" alt="Untitled"> <strong>我们也可以给statement添加一个BFC，让statement成为一个独立渲染的区域不影响外部</strong> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.statement</span>&#123;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="number">2em</span>;</span><br><span class="line"><span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 再刷新一下 <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/80da0761-de79-4316-bb00-986e8bb094ed/Untitled.png" alt="Untitled"> 这样就可以使元素（statement）包裹着浮动元素了</li><li><strong>解决margin collapse</strong> 还是上面的例子，p标签太近了，我们添加个属性margin <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">1.7em</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa024b86-4b5f-4d6d-944e-c1add2435284/ezgif-2-50fe72f50912.gif" alt="ezgif-2-50fe72f50912.gif"> 可以看到这里发生了一开始我们提到的外边距重叠（margin collapse），我也提到了这是专门这样子设计的，不是bug，怎么解决呢，没错，上面解决方案的第七个，可以创建一个BFC <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;statement&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam</span><br><span class="line">        harum voluptas ullam, quia veniam sunt in maiores optio</span><br><span class="line">        laboriosam, earum minus veritatis deserunt delectus repellendus</span><br><span class="line">        eaque nostrum vitae! Amet, alias.</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam</span><br><span class="line">        harum voluptas ullam, quia veniam sunt in maiores optio</span><br><span class="line">        laboriosam, earum minus veritatis deserunt delectus repellendus</span><br><span class="line">        eaque nostrum vitae! Amet, alias.</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.statement</span> <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 给p套一个div，让这个div形成一个BFC独立渲染 <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ef44d4f2-7da1-414e-a079-5ee71048778c/Untitled.png" alt="Untitled"> 这样就可以防止外边距重叠了</li></ol><p>创建BFC有以下（用得比较多得加黑了</p><ol><li><html/> 跟元素</li><li><strong>设置了float属性且值不为none的元素</strong></li><li>绝对定位的元素（position:absolute)</li><li><strong>设置了display:inline-block/ flow-root的元素</strong></li><li>设置了display:table-<em>的元素（例如table-cell、table-caption、table-row*<em>等）</em></em></li><li><strong>设置了overflow值不为visible和clip以外的元素（例如：overflow:hidden)</strong></li><li>设置contain的元素（layout | content | paint)</li><li>flex 和grid布局的子元素（非flex和grid布局容器本身）</li><li>多列布局，设置了column-count的元素，或设置了column-span:all的元素</li></ol><p><strong>提示</strong>：<code>display: flow-root</code>，<code>contain: layout</code> 等是无副作用的，可在不影响已有布局的情况下触发 BFC，所以会用的比较多</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;外边距重叠&quot;&gt;&lt;a href=&quot;#外边距重叠&quot; class=&quot;headerlink&quot; title=&quot;外边距重叠&quot;&gt;&lt;/a&gt;外边距重叠&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;外边距重叠（英文margin collapse，MDN 的解释如下：  块的顶部和底部边距有时合并(折叠</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nginx反向代理和负载均衡</title>
    <link href="https://oshino.cc/2021/10/16/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://oshino.cc/2021/10/16/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2021-10-16T08:37:28.000Z</published>
    <updated>2021-12-16T08:37:37.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识部分nginx-conf"><a href="#认识部分nginx-conf" class="headerlink" title="认识部分nginx.conf"></a>认识部分nginx.conf</h3><ol><li>文件结构 打开nginx.conf（nginx我用的openresty，集成了一些插件，省大把时间），吧注释的说明都去掉，留下一个整洁的模板，长这样： <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root html;</span><br><span class="line">index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 文件分成三块<ol><li><strong>全局配置模块</strong> 影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等，worker_processes表示处理并发数，越大处理的越多，不过和硬件等有关</li><li><strong>events配置模块</strong> 主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。上述表示最大的连接数为1024</li><li><strong>http配置模块（http模块里又分为http全局块和server模块）</strong>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。<ol><li><strong>全局模块</strong> http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</li><li><strong>server模块（该模块可以有多个，且模块又分为server全局块和location模块）</strong><ol><li><strong>全局块</strong> 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。</li><li><strong>location</strong> 一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx  服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</li></ol></li></ol></li></ol> 看上去像这样： <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ca9517e6-2cb6-4dea-b5cf-44161fc957d2/Untitled.png" alt="Untitled"></li><li>部分常用字段和功能 该文件是nginx到配置文件<table><thead><tr><th>字段</th><th>功能</th></tr></thead><tbody><tr><td>worker_processes</td><td>指明nginx要开启的进程数</td></tr><tr><td>worker_connections</td><td>单个工作进程可以允许同时建立外部连接的数量</td></tr><tr><td>defult_type</td><td>响应类型：有application/octet-stream(下载)和application/text/html(网页 )</td></tr><tr><td>include</td><td>配置多的时候会分成多个文件，可以用此指令汇总</td></tr><tr><td>sendfile</td><td>提高文件的传输速率，开启后会用sendFile()</td></tr><tr><td>keepalive_timeout</td><td>规定http请求keep-alive持续的时间，不要太大，好释放资源，提高性能</td></tr><tr><td>location</td><td>通过指定模式来与客户端请求的URI相匹配</td></tr><tr><td>server_name</td><td>指明host</td></tr><tr><td>listen</td><td>该字段出现在server里，指明端口号</td></tr><tr><td>error_page</td><td>当发生错误的时候能够显示一个预定义的uri</td></tr><tr><td>proxy_pass</td><td>反向代理字段</td></tr><tr><td>upstream</td><td>负载均衡配置模块</td></tr><tr><td></td><td></td></tr><tr><td>location 匹配规则</td><td></td></tr><tr><td></td><td></td></tr><tr><td>有四个优先级别</td><td></td></tr><tr><td></td><td></td></tr></tbody></table><ol><li>“=”级别最高 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /a&#123;</span><br><span class="line">echo &quot;this is the most higt level&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>”^~“级别其次 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /a &#123;</span><br><span class="line">echo &quot;this is the second level&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>“～”级别第三 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ /\w &#123;</span><br><span class="line">echo &quot;this is the third level&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>“普通字符串” <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">echo &quot;this is the final level&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li>同优先级别的，匹配程度较高的先匹配</li><li>匹配程度一样的，则写在前面的先匹配</li></ol><p><strong>作为一个前端er，了解这些就够了吧，接下来就进入主菜</strong></p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>开启nginx后默认是80端口，我因为端口号被占用，修改成了8080，访问localhost:8080</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a07dd9d-7908-46a0-9a0a-2d3d58d96156/Untitled.png" alt="Untitled"></p><p>我用node自己开了个服务，端口号为8080，访问成功：</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ce31c11f-367b-4daa-afc2-8ca73be7d610/Untitled.png" alt="Untitled"></p><p>反向代理我们只需要用到proxy_pass字段，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"># 响应类型改为html</span><br><span class="line">        default_type  text/html;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://localhost:8080</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/51326170-f9b7-4973-8d7a-fbeab127bd1c/Untitled.png" alt="Untitled"></p><p>可以看到访问默认的80端口，也会因反向代理转到8080端口</p><hr><p><strong>反向代理需要注意的点就是proxy_pass的路径要与location的规则一起用</strong></p><hr><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li><pre><code>      负载均衡的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。      通过负载均衡，可以让每台服务器获取到适合自己处理能力的负载。在为高负载服务器分流的同时，还可以避免资源浪费，一举两得。      负载均衡可分为软件负载均衡和硬件负载均衡。在我们日常开发中，一般很难接触到硬件负载均衡。但软件负载均衡还是比如我们接下来会讲到的ngxin</code></pre></li></ul><p>可以这么配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">####################################</span><br><span class="line">####### 在这里添加一个upstream 字段####</span><br><span class="line">upstream serverGroups&#123;</span><br><span class="line">server localhost:80;</span><br><span class="line">server localhost:8080;</span><br><span class="line"></span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br><span class="line">####################################</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        default_type  text/html;</span><br><span class="line">        location / &#123;</span><br><span class="line">####################################</span><br><span class="line"># 在这里啊host替换成上面的upstream名字 #</span><br><span class="line">            proxy_pass http://serverGroups</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看看效果</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a0bc010f-0536-4ee8-9698-d059af1b4511/Untitled.png" alt="Untitled"></p><p>自此，反向代理和负载均衡就大概是这样，我觉得作为前端er了解知道怎么弄就行，不需要去深入了解配置参数啥的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;认识部分nginx-conf&quot;&gt;&lt;a href=&quot;#认识部分nginx-conf&quot; class=&quot;headerlink&quot; title=&quot;认识部分nginx.conf&quot;&gt;&lt;/a&gt;认识部分nginx.conf&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;文件结构 打开nginx.con</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>回来了回来了</title>
    <link href="https://oshino.cc/2021/10/08/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86/"/>
    <id>https://oshino.cc/2021/10/08/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86/</id>
    <published>2021-10-08T15:23:00.000Z</published>
    <updated>2021-12-16T14:52:34.153Z</updated>
    
    <content type="html"><![CDATA[<p>　　我回来了，不知道多久没写博文了，这次开学后打算重拾起我前两年的自制力，想到这我就想到开始写博客。</p><p>　　好了，我换电脑了，m1 mba，这次不想折腾太多（还是要折腾的，我对UI有点要求），wordpress直接pass掉了，由于也不想碰其他平台且在在18年用过hexo，所以这次就直接用hexo了，搭建很快就不罗嗦了，买了个域名oshino.cc也顺便绑定上，这三年不出意外应该都是用这个域名了，我目前用的是github找的主题Anatole，它的主体框架和我想要的一样，后面稳定下来后再拿来DIY吧。</p><p>　　因为课程基本都学会了（没会的我也不感兴趣），所以我打算自己找点事情做，最终想来想去打算自己在这个主题的基础上DIY，故开了这个坑，接下来的阶段是这么打算的：</p><ol><li>需求分析</li><li>设计UI（我不是专业的</li><li>网上查找hexo主题开发的资料，我略微查了一下，普遍都说hexo的文档非常差</li><li>在进行3的同时用vscode进行主题开发</li><li>完善博客，添加插件，博客我打算以阅读为主，所以不出意外只会添加rss和评论这两个</li></ol><p>后续我会不断更新这篇文章</p><blockquote><p>更新于10.06</p></blockquote><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>　　现在是早上8点多，待会中午要坐车回去学校了，老家到佛山的距离，加上塞车，已经准备好塞个10小时了（高铁票好难买~）</p><p><img src="https://files.catbox.moe/7n5g49.png" alt="blog 需求"></p><p>　　可以看到目前是很简单的一个version，因为是以阅读为主，所以砍掉了很多多余的需求，后面会更加注重文字排版、选文字、行高的细节设计（当然我都是外行人），先用processOn吧模块简要的写出来，方便后面原型UI设计，不用想什么加什么</p><blockquote><p>更新于10.10</p></blockquote><h4 id="原型UI设计"><a href="#原型UI设计" class="headerlink" title="原型UI设计"></a>原型UI设计</h4><p>　　原型UI设计真难啊，虽然我有大概框架，可正真实施下来，还是感觉空荡荡的，少了些什么，先这样子放着吧，看到时候再改进！</p><blockquote><blockquote><p>这是HOME页的，文字用程序生成的，看看就好</p></blockquote></blockquote><p><img src="https://files.catbox.moe/c1bdig.png" alt="HONME"><br><img src="https://files.catbox.moe/75ojvv.png" alt="HOME"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;　　我回来了，不知道多久没写博文了，这次开学后打算重拾起我前两年的自制力，想到这我就想到开始写博客。&lt;/p&gt;
&lt;p&gt;　　好了，我换电脑了，m1 mba，这次不想折腾太多（还是要折腾的，我对UI有点要求），wordpress直接pass掉了，由于也不想碰其他平台且在在18年用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="https://oshino.cc/2021/03/18/%E8%B7%A8%E5%9F%9F/"/>
    <id>https://oshino.cc/2021/03/18/%E8%B7%A8%E5%9F%9F/</id>
    <published>2021-03-18T15:23:00.000Z</published>
    <updated>2021-12-16T08:35:53.184Z</updated>
    
    <content type="html"><![CDATA[<p>假设一种情景</p><pre><code>我对某网站要搞点小心思，因为对方服务器进不了，所以我把小心思放在我的服务器，封装成一个接口暴露出去，然后等我使用他的网站时，再请求我服务器的接口，搞烂他！ttk !</code></pre><p>我真聪明！</p><p>。。。。。。</p><p>origin cors？好吧这个方法好像行不通，那我换个方法，吧小心思包装成一个软件，在互联网传播，等他服务器下载之后运行，我再植入到他的网站首页的script标签运行，偷偷冲他的网站！！嘿嘿嘿我真聪明！</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ea226ddb-8dec-438a-aa33-5ba777467012/Untitled.png" alt="Untitled"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ooooshino的网站</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 我们通过某种手段想让对方网站运行我们的端口的脚本</span></span></span><br><span class="line"><span class="javascript">  fetch(<span class="string">&quot;http://localhost:8081&quot;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;在这里做小动作&quot;</span>);</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">&lt;/scrip&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f776d5f2-677f-4dce-b740-94125b2eae84/Untitled.png" alt="Untitled"></p><p>？？？？</p><p>傻逼<strong>浏览器</strong>，阻止我积累战绩！ttk！！！</p><p>以上这些都是跨域导致的错误，跨域是浏览器为了<strong>请求安全</strong>而引入的基于<strong>同源策略</strong>的安全特性，需注意的是，这个跨域报错是<strong>浏览器</strong>的行为，和服务端没有关系，请求是正常返回了，只是卡在了浏览器这边</p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">MDN</a>是这样说明的：</p><ul><li>如果两个 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">protocol</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port (en-US)</a> (如果有指定的话)和 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）  <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5aa890cd-8af9-45ee-98f9-7bc773128316/Untitled.png" alt="Untitled"></li></ul><p>我们上面的情况有host或者port不同，其他不变的情况，都造成了跨域问题</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>目前较为流行的有三种</p><ol><li>cors</li><li>jsonp</li><li>反向代理</li></ol><h3 id="1-CORS通信（Cross-Origin-Resource-Sharing）"><a href="#1-CORS通信（Cross-Origin-Resource-Sharing）" class="headerlink" title="1. CORS通信（Cross-Origin Resource Sharing）"></a>1. CORS通信（Cross-Origin Resource Sharing）</h3><p>cors是http的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。采用cors的话只需要服务端修改一下请求头的Access-Control-Allow-Origin字段，该方案涉及到服务端，前端不需要修改，例如上面的例子我们可以改成：</p><p>除了上面这个请求头，添加的时候还有以下选择：</p><table><thead><tr><th>字段</th><th>功能</th></tr></thead><tbody><tr><td>Access-Control-Allow-Origin</td><td>表示允许的来源</td></tr><tr><td>Access-Control-Allow-methods</td><td>表示允许的请求方法</td></tr><tr><td>Access-Control-Allow-Headers</td><td>表示允许的请求头</td></tr><tr><td>Access-Control-Allow-Credentials</td><td>表示允许携带认证信息</td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app1.get(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, resp</span>) =&gt;</span> &#123;</span><br><span class="line">  resp.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="comment">// 或者直接添加header字段“Access-Control-Allow-*”也可以</span></span><br><span class="line">  resp.send(<span class="string">&quot;嘿嘿嘿，成功访问后我要搞烂你！！！&quot;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ooooshino的网站</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//前端再去访问该api就不会发生跨域问题了</span></span></span><br><span class="line"><span class="javascript">  fetch(<span class="string">&quot;http://localhost:8081&quot;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    res.text().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      alert(data);</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/46d36e97-bb09-4bed-bdbc-1c87449d95d8/Untitled.png" alt="Untitled"></p><h3 id="2-jsonp"><a href="#2-jsonp" class="headerlink" title="2. jsonp"></a>2. jsonp</h3><p>JSONP 的原理是利用了浏览器加载 JavaScript 资源文件时不受同源策略的限制而实现的。把我们的请求变成一个资源请求，然后吧”小心思“弄成函数，当作资源请求的参数传入，这样吧函数在服务端处理后又返回去浏览器，就可以了！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ooooshino的网站</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> trick = <span class="function">(<span class="params">data</span>) =&gt;</span> alert(date);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8081?callback=trick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app1.get(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, resp</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> trickFunction = req.query.callback;</span><br><span class="line">  resp.send(trickFunction+<span class="string">&quot;(&#x27;嘿嘿嘿，成功访问后我要搞烂你！！！&#x27;)&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c6388302-e63e-4b16-a948-aee855331ab2/Untitled.png" alt="Untitled"></p><p>也是成功访问到api了</p><h3 id="3-反向代理"><a href="#3-反向代理" class="headerlink" title="3. 反向代理"></a>3. 反向代理</h3><p>我在<a href="https://www.notion.so/Nginx-fdb720c5c3324ba093280b8d92973c0c">这里</a>讲过了，就不多说了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假设一种情景&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我对某网站要搞点小心思，因为对方服务器进不了，所以我把小心思放在我的服务器，封装成一个接口暴露出去，然后等我使用他的网站时，再请求我服务器的接口，搞烂他！ttk !
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我真聪明！&lt;/p&gt;
&lt;p&gt;。。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://oshino.cc/2020/08/08/ES6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://oshino.cc/2020/08/08/ES6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-08T06:14:27.000Z</published>
    <updated>2020-08-08T06:14:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6学习总结"><a href="#ES6学习总结" class="headerlink" title="ES6学习总结"></a>ES6学习总结</h1><p>该学习笔记参考阮一峰的ES6教程 <a href="%22http://es6.ruanyifeng.com/#docs/destructuring%22">点击我查看</a></p><h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><p>let和var一样，用来声明变量，ES6比以往全局作用域和函数作用域，多出来一个块级作用域，一个{}即为一个块级作用域，这是为了避免函数内的变量提升从而覆盖函数顶层所声明的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*****************<span class="number">1.</span> 用<span class="keyword">let</span>声明的变量只适用于该作用域*********************</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> variable1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> variable2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(variable1)  <span class="comment">//打印出1</span></span><br><span class="line"><span class="built_in">console</span>.log(variable2)  <span class="comment">//报错，variable2 is not defined</span></span><br><span class="line">*****************<span class="number">2.</span> 用<span class="keyword">let</span>声明的变量不存在变量提升**********************</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line">*****************<span class="number">3.</span> 用<span class="keyword">let</span>声明的变量暂时性死区**************************</span><br><span class="line"></span><br><span class="line">*****************<span class="number">4.</span> 用<span class="keyword">let</span>声明的变量不允许重复声明**********************</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const同样也是声明，不过const声明的是常量，且一旦声明，后面就不能改了，这也意味着用const在声明常量的时候，必须初始化初值，作用域和let一样，不存在提升，同样也拥有TDZ</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 没有初值</span></span><br><span class="line"><span class="keyword">const</span> constant;  <span class="comment">//报错 Missing initializer in const declaration</span></span><br><span class="line"><span class="comment">//2. 不能修改</span></span><br><span class="line"><span class="keyword">const</span> constant = <span class="number">2</span>;</span><br><span class="line">constant = <span class="number">4</span>;    <span class="comment">//报错TypeError: Assignment to constant variable</span></span><br><span class="line"><span class="comment">//3. 存在TDZ</span></span><br><span class="line"><span class="built_in">console</span>.log(constant); <span class="comment">//Cannot access &#x27;constant&#x27; before initialization</span></span><br><span class="line"><span class="keyword">const</span> constant = <span class="number">123</span>;</span><br><span class="line"><span class="comment">//4.只适用于当前的作用域</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> constant = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(constant)    <span class="comment">//123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(constant)    <span class="comment">//Uncaught ReferenceError: MAX is not defined</span></span><br><span class="line"><span class="comment">//5. 不可重复</span></span><br><span class="line"><span class="keyword">const</span> constant = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">const</span> constant = <span class="number">321</span>;   <span class="comment">//报错Identifier &#x27;sss&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><p>const声明的本质，是将所声明的名称指向常量的内存地址，这意味着在所指向 内存地址不改变的情况下，是可以改变的，下面给出例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> constantList = [];</span><br><span class="line"><span class="comment">// 添加内容成功</span></span><br><span class="line">constantList.push(<span class="string">`123`</span>)    <span class="comment">//success</span></span><br><span class="line"><span class="comment">// 打印constantList长度</span></span><br><span class="line"><span class="built_in">console</span>.log(constantList.length)  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 让constantList长度为0,即清空constantList</span></span><br><span class="line">constantList.length = <span class="number">0</span>;  <span class="comment">//success</span></span><br><span class="line"><span class="comment">// 打印constantList</span></span><br><span class="line"><span class="built_in">console</span>.log(constantList)   <span class="comment">// []</span></span><br><span class="line"><span class="comment">// 改变指向的内存地址</span></span><br><span class="line">constantList = [<span class="string">`123`</span>]   <span class="comment">//报错Assignment to constant variable.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>语法糖：</p><ol><li>如果只有一个参数，（）可以省</li><li>如果只有一个return,{}可以省</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5或者更老版本</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>)     <span class="comment">//   打印 123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------------------</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">124</span>,<span class="number">5151</span>,<span class="number">32</span>,<span class="number">513</span>,<span class="number">5</span>,<span class="number">54</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">51</span>,<span class="number">32</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">n,m</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n-m;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr);     <span class="comment">// [1, 5, 32, 32, 32, 51, 54, 124, 513, 5151]</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------</span></span><br><span class="line"><span class="keyword">var</span> testFunction = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(testFunction(<span class="number">123</span>));    <span class="comment">//打印123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6, 对应输出和上面一样</span></span><br><span class="line"><span class="comment">//去掉 function</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------------------</span></span><br><span class="line"><span class="comment">//单独一个return, 去掉 function 和 &#123;&#125;</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">124</span>,<span class="number">5151</span>,<span class="number">32</span>,<span class="number">513</span>,<span class="number">5</span>,<span class="number">54</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">51</span>,<span class="number">32</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">n,m</span>) =&gt;</span> n-m);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//----------------------------------------------------------</span></span><br><span class="line"><span class="comment">//单独一个return 和只有一个参数，function() 和 &#123;&#125; 都去掉</span></span><br><span class="line"><span class="keyword">let</span> testFunctino = <span class="function">() =&gt;</span> a</span><br><span class="line"><span class="built_in">console</span>.log(testFunction(<span class="number">123</span>));</span><br></pre></td></tr></table></figure><h2 id="参数扩展"><a href="#参数扩展" class="headerlink" title="参数扩展"></a><strong>参数扩展</strong></h2><p>…args</p><ol><li><p>收集剩余参数</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="function">(<span class="params">a,b,...args</span>) =&gt;</span> args;</span><br><span class="line"><span class="built_in">console</span>.log(test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>));     <span class="comment">//  3,4,5,6,7,8,9</span></span><br></pre></td></tr></table></figure></li><li><p>展开数组</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(...arr);</span><br><span class="line"><span class="keyword">let</span> expandArr = <span class="function">(<span class="params">a,b,c,d,e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line">expandArr(...arr);<span class="comment">//  换行打印出  1  2  3  45  6</span></span><br></pre></td></tr></table></figure><p> 展开是特别好用的，任何能用到的…都可以拿出来用</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">ler arr = [...arr1,...arr2];</span><br><span class="line"><span class="built_in">console</span>.log(arr);           <span class="comment">//  1,2,3,4,5,6,7,8</span></span><br></pre></td></tr></table></figure></li><li><p>默认参数</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="function">(<span class="params">a=<span class="number">2</span></span>) =&gt;</span> a;</span><br><span class="line">test();     <span class="comment">// 打印 2</span></span><br></pre></td></tr></table></figure><p> 注意： 一个参数且有默认值的情况下，不能省略掉()</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = a=<span class="number">2</span> =&gt; a;     <span class="comment">//报错 Malformed arrow function parameter list</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>左右两边一一对应，解构赋值需要注意的有：</p><ol><li><p>左右两边结构一样</p></li><li><p>赋值和声明在一起进行</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c,d,e] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">`a`</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span><span class="subst">$&#123;c&#125;</span><span class="subst">$&#123;d&#125;</span><span class="subst">$&#123;e&#125;</span>`</span>);     <span class="comment">// 1234e</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [&#123;a,b,c&#125;,[d,e,f],num,str] = [&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>&#125;,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">789</span>,<span class="string">&#x27;10&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c,d,e,f,num,str);        <span class="comment">// 1 2 3 4 5 6 789 &quot;10&quot;</span></span><br></pre></td></tr></table></figure><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><ol><li>map        映射</li><li>reduce     汇总</li><li>filter     过滤器</li><li>forEach    循环</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------------------------.map----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scoreList = [<span class="number">12</span>,<span class="number">58</span>,<span class="number">89</span>,<span class="number">93</span>,<span class="number">70</span>];</span><br><span class="line"><span class="keyword">let</span> scoreRes = scoreList.map(<span class="function"><span class="params">score</span> =&gt;</span> score&gt;<span class="number">85</span>?<span class="string">&#x27;优秀&#x27;</span>:(score&gt;<span class="number">69</span>?<span class="string">&#x27;良好&#x27;</span>:<span class="string">&#x27;不及格&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(scoreRes);     <span class="comment">// [&quot;不及格&quot;, &quot;不及格&quot;, &quot;优秀&quot;, &quot;优秀&quot;, &quot;良好&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------.reduce----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .reduce(temp，item,index)</span></span><br><span class="line"><span class="comment">// @temp 临时中间值</span></span><br><span class="line"><span class="comment">// @item 当前的值</span></span><br><span class="line"><span class="comment">// @index 当前值的下标</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">71</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">tmp,item,index</span>) =&gt;</span> &#123;<span class="keyword">return</span> tmp+item;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result);              <span class="comment">// 103</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------.filter----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据函数返回的Boolean值来确定是否要保留</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">72</span>,<span class="number">6</span>,<span class="number">72</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.filter(<span class="function"><span class="params">item</span>=&gt;</span> item%<span class="number">3</span>==<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result)    <span class="comment">// [12, 3, 6, 72, 6, 72]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------.forEach----------------------------------</span></span><br><span class="line"><span class="comment">// 迭代每一个元素</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(item);&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了item,还有index</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>];</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//换行打印 下标为0的值为：1 下标为1的值为：2  下标....</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`下标为<span class="subst">$&#123;index&#125;</span>的值为：<span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">&#125;);  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a><strong>字符串模板</strong></h2><p>ES6新增两个方法,一个特性</p><ol><li>startsWith(String) endsWith(String)返回结果是个Boolean类型</li><li>超级方便的字符串模板</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startsWith  endsWith</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`ascdfd`</span>;</span><br><span class="line">str.startsWith(<span class="string">`a`</span>);     <span class="comment">//    true</span></span><br><span class="line">str.startsWith(<span class="string">`2`</span>);     <span class="comment">//    false</span></span><br><span class="line">str.endsWith(<span class="string">`d`</span>);       <span class="comment">//    true</span></span><br><span class="line">str.endsWith(<span class="string">`1`</span>);       <span class="comment">//    false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串模板</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">`http://liangyiyuan.fun/`</span></span><br><span class="line"><span class="keyword">let</span> uri = <span class="string">`<span class="subst">$&#123;url&#125;</span>getUserInfo`</span></span><br><span class="line"><span class="built_in">console</span>.log(uri);     <span class="comment">//    http://liangyiyuan.fun/getUserInfo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>ES6终于对面向对象进行了优化,(之前的写法是真的恶心=-=),有两个变化</p><ol><li><p>构造函数和类分开了,多了class关键字</p></li><li><p>class里面直接加方法</p></li><li><p>继承语法</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------------老版面向对象</span></span><br><span class="line"><span class="comment">// 1.创建类</span></span><br><span class="line">functino <span class="function"><span class="title">User</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.方法</span></span><br><span class="line">User.prototype.showName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(<span class="string">`Ethan`</span>);</span><br><span class="line">user.showName();      <span class="comment">//    Ethan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------ES6面向对象</span></span><br><span class="line"><span class="comment">// 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(<span class="string">&#x27;Ethan&#x27;</span>);</span><br><span class="line">user.showName();</span><br></pre></td></tr></table></figure><p>老版的继承也是写的很是让人无语</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------老版继承,这里User已经创建</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vipUser</span>(<span class="params">name,level</span>)</span>&#123;</span><br><span class="line">    User.call(<span class="built_in">this</span>,name);</span><br><span class="line">    <span class="built_in">this</span>.level = level;</span><br><span class="line">&#125;</span><br><span class="line">vipUser.prototype = <span class="keyword">new</span> User();</span><br><span class="line">vipUser.prototype.constuctor = vipUser;</span><br><span class="line">vipUser.prototype.showLevel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.level);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(<span class="string">`Ethan`</span>,<span class="number">10</span>);</span><br><span class="line">user.showLevel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//我枯了.....让我们来看看新版的继承</span></span><br><span class="line"><span class="comment">//-----------------------新版继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vipUser</span> <span class="keyword">extends</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,level</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">showLevel</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(<span class="string">`Ethan`</span>,<span class="number">10</span>);</span><br><span class="line">user.showLevel();</span><br></pre></td></tr></table></figure><p>这….这TM才是面向对像! 这TM才是继承阿! 学过java的感觉见到了熟人, 之前的都是些什么鬼, 我爱ES6!!!</p><p>这里不得提一下java不愧是世界上最热门的语言,ES6的面向对象语法也在向他靠</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ol><li><p>json对象</p><p> 由于这不是ES6才有的, 所以就不举例子了, json对象有两个方法:</p><p> JSON.stringify   ==&gt; json 转 str</p><p> JSON.parse   ==&gt; str 转 json</p></li><li><p>ES6增加了json的简写</p><p> (1) 当key 和value一样的时候,可以只写一个;</p><p> (2) 当value为function时,function()这个关键字可去掉</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key和value都是一样的</span></span><br><span class="line"><span class="keyword">let</span> [a,b] = [<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> json = &#123;a,b,<span class="attr">c</span>:<span class="number">33</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(json);   <span class="comment">//     &#123;a:2,b:3,c:33&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// value为function时,可以去掉 :function</span></span><br><span class="line"><span class="keyword">let</span> json = &#123;</span><br><span class="line">    a,b,<span class="attr">c</span>:<span class="function"><span class="title">functino</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以简写为</span></span><br><span class="line"><span class="keyword">let</span> json = &#123;</span><br><span class="line">    a,b,<span class="function"><span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">json.c();      <span class="comment">//  打印23</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a><strong>Promise对象</strong></h2><p>promise是一种<strong>用同步的方式写异步</strong>的规范</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   创建一个promise对象</span></span><br><span class="line"><span class="keyword">let</span> promiseOne = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="title">functio</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//异步代码  比如在这发请求</span></span><br><span class="line">    wx.request(&#123;</span><br><span class="line">        url,</span><br><span class="line">        data,</span><br><span class="line">        header,</span><br><span class="line">        <span class="attr">success</span>:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(res);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fail</span>:<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promiseOne.then(</span><br><span class="line">    <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>假如在这还有一个promise对象, 还要继续用 promiseTwo.then(){} 就显得有点鸡肋</p><p>promise提供了Promise.all(promise对象数组,then(){}) ,比如这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promiseTwo = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="title">functio</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//请求</span></span><br><span class="line">    wx.request(&#123;</span><br><span class="line">        url,</span><br><span class="line">        data,</span><br><span class="line">        header,</span><br><span class="line">        <span class="attr">success</span>:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(res);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fail</span>:<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all([promiseOne,promiseTwo]).then(</span><br><span class="line">    <span class="comment">//   resolve调用的前提是promiseOne和promiseTwo都调用成功了,只要一个失败,都会调用reject</span></span><br><span class="line">    <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`至少有一个失败了`</span>);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>在这里打印出res,会发现有两个请求的结果,所以我们可以这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([promiseOne,promiseTwo]).then(</span><br><span class="line">      <span class="comment">//   resolve调用的前提是promiseOne和promiseTwo都调用成功了,只要一个失败,都会调用reject</span></span><br><span class="line">      <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> [res1,res2] = res;</span><br><span class="line">          <span class="built_in">console</span>.log(res1);    <span class="comment">//第一个请求的结果</span></span><br><span class="line">          <span class="built_in">console</span>.log(res2);    <span class="comment">//第二个请求的结果</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">`至少有一个失败了`</span>);</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><p>每次都要let promiseObject = new Promise(){} 会使得代码量冗余,我们可以搞一个封装 !</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对请求进行封装,添加data,header等参数就不举例了</span></span><br><span class="line">functino createPromise(method,url))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        wx.request(&#123;</span><br><span class="line">            method,  <span class="comment">//默认`GET`</span></span><br><span class="line">            url,</span><br><span class="line">            <span class="attr">success</span>:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">fail</span>:<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    createPromise(url1),</span><br><span class="line">    createPromise(url2)</span><br><span class="line">]).then(</span><br><span class="line">    <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> [res1,res2] = res;</span><br><span class="line">        <span class="built_in">console</span>.log(res1);    <span class="comment">//第一个请求的结果</span></span><br><span class="line">        <span class="built_in">console</span>.log(res2);    <span class="comment">//第二个请求的结果</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`至少有一个失败了`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><p>小科普: <strong>Jquery的ajax返回的就是个promise对象</strong>, 请看下面小例子 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    $.ajax(&#123;url1,data-type;<span class="string">`json`</span>&#125;),</span><br><span class="line">    $.ajax(&#123;url2,data-type;<span class="string">`json`</span>&#125;)</span><br><span class="line">]).then(</span><br><span class="line">    <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`两个请求都成功了`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`至少一个失败了`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对,就是这么简洁….</p><hr><p>Promise除了Promise.all()之外,还有Promise.race()</p><p>简单来讲all需要数组下的请求都成功才会调用resolve,否则调用reject, 而race只要有一个先成功的,就会调用resolve, 且只调用最快的那个, 用得很少,经常用来保障大型业务正常运行,比如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="comment">//这三个地址返回的资源都是一样的,像淘宝这种有多个服务器</span></span><br><span class="line">    <span class="comment">//一个服务器炸了,其他服务器就派上用场了,用户还是能正常拿到数据</span></span><br><span class="line">    $.ajax(&#123;url1,data-type:<span class="string">`json`</span>&#125;),</span><br><span class="line">    $.ajax(&#123;url2,data-type:<span class="string">`json`</span>&#125;),</span><br><span class="line">    $.ajax(&#123;url3,data-type:<span class="string">`json`</span>&#125;),</span><br><span class="line">    $.ajax(&#123;url4,data-type:<span class="string">`json`</span>&#125;)</span><br><span class="line">]).then(</span><br><span class="line">    <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`拿到数据啦:<span class="subst">$&#123;res&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`都GG啦`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Set对象"><a href="#Set对象" class="headerlink" title="Set对象"></a>Set对象</h2><p>这是ES6新增的数据结构，类似于数组，但于数组不同的是，Set对象的值不能有重复</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建set对象   迭代添加   输出</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>].forEach(<span class="function"><span class="params">item</span> =&gt;</span> set.add(item));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> set)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)      <span class="comment">// 换行打印 1  2  3  4  5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以在set对象创建的时候初始化值</span></span><br><span class="line"><span class="keyword">const</span> setTwo = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(setTwo.size);        <span class="comment">// 打印 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> setThree = <span class="keyword">new</span> <span class="built_in">Set</span>([...arr]);</span><br><span class="line"><span class="built_in">console</span>.log(setThree.size);     <span class="comment">// 打印 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，set在添加值的时候，数据类型不会发生转换</span></span><br></pre></td></tr></table></figure><p>set对象有以下属性和方法 ：</p><p>属性：</p><ol><li>constructor　　　　　 　　　—构造函数，默认就是set函数</li><li>size　　　　　 　　　　　　—返回set实例的成员总数</li></ol><p>方法：</p><ol><li>.add(value)　　　　　 　　—添加某个值，返回set结构本身</li><li>.delete(value)　　　　　　— 删除某个值，返回一个布尔值</li><li>.has(value)　　　　　　 　— 返回一个Boolean,表示该值是否为set成员</li><li>.clear()　　　　　　　　　—清楚所有的成员，没有返回值</li></ol><h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a><strong>generator</strong></h2><p>generator,生成器,生成一个函数,于不普通函数一路到底不同的是,generator函数中间可以暂停,下次执行的时候,从暂停的地方开始执行,需要和yield配对使用,且不能像函数那样 函数名()调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用`*`代表这是一个generator,放置的位置有三种</span></span><br><span class="line"><span class="comment">//1.function* generator()&#123;&#125;</span></span><br><span class="line"><span class="comment">//2.function * generator()&#123;&#125;</span></span><br><span class="line"><span class="comment">//3.function *generator()&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generatorTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`a`</span>);</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`b`</span>);</span><br><span class="line">&#125;</span><br><span class="line">generatorTest(); <span class="comment">//直接调用generator无效</span></span><br><span class="line">generatorTest.next();  <span class="comment">// 打印 a ,在yield这里停住</span></span><br></pre></td></tr></table></figure><ol><li><p>yield的使用</p><p> yield可以传参,具体值放在 .next(这里传参) 里</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generatorTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`a`</span>);</span><br><span class="line">    <span class="keyword">let</span> a = field;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">generatorTest.next(<span class="number">23</span>);     <span class="comment">// 打印 a</span></span><br><span class="line">generatorTest.next(<span class="number">123</span>);    <span class="comment">// 打印 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的23并不是被123覆盖了,而是yield传参是从第二个开始,第一个传参是没用的</span></span><br></pre></td></tr></table></figure></li><li><p>yield返回value值</p><p> 执行过上面的代码,会发现除了打印a和123,还有会两个json对象,每次next一个json对象</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&#123;value:undefined,done:false&#125;</span></span><br><span class="line"><span class="comment">//&#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure><p> <strong>把值放在yield后面,每次执行完都会返回对应的值,最后一个没有yield,用return返回值</strong>, 例子 :</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generatorTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">`a`</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">123</span>;</span><br><span class="line">    alert(<span class="string">`b`</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">456</span>;</span><br><span class="line">    alert(<span class="string">`c`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">789</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorTest = generatorTest();</span><br><span class="line">generatorTest.next();     <span class="comment">//  &#123;value:123,done:false&#125;</span></span><br><span class="line">generatorTest.next();     <span class="comment">//  &#123;value:456,done:false&#125;</span></span><br><span class="line">generatorTest.next();     <span class="comment">//  &#123;value:789,done:true&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>generator可以解决异步操作</strong> ! ! !</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ES6学习总结&quot;&gt;&lt;a href=&quot;#ES6学习总结&quot; class=&quot;headerlink&quot; title=&quot;ES6学习总结&quot;&gt;&lt;/a&gt;ES6学习总结&lt;/h1&gt;&lt;p&gt;该学习笔记参考阮一峰的ES6教程 &lt;a href=&quot;%22http://es6.ruanyifeng</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://oshino.cc/2020/08/08/docker/"/>
    <id>https://oshino.cc/2020/08/08/docker/</id>
    <published>2020-08-08T06:14:27.000Z</published>
    <updated>2020-08-08T06:14:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习笔记"><a href="#Docker学习笔记" class="headerlink" title="Docker学习笔记"></a>Docker学习笔记</h1><h2 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>什么是docker，我认为docker你可以看成一个集装箱，每个箱子的空间所做的事情，都是互不相干的，docker如今已经发展成了一个生态体系，很多服务和系统都围绕着docker来写，因此，作为一个程序员，学习docker是必不可少的，docker对于开发人员还有这一句口号：Build once,Run anywhere,对于运维人员也有一句：Configure once,Run anywhere。</p><p>docker采用的是容器化技术，人们通常会拿来和虚拟机来比较</p><p>虚拟机采用的底层硬件的支持和虚拟化技术，在一台电脑上开辟一块空间，独立的运行一个新系统（Guest OS）</p><p>然后再打包软件再这些系统上运行，这样的话比较安装，因为系统与系统之间是独立的</p><p>而容器技术，则没有采用虚拟机技术，运行起来也相对轻量，运行的时候直接共享宿主机的linux内核的Cgroup和namespace,来做到资源的隔离和限制，导致每个容器再运行的时候，是宿主机的一个特殊进程，有利也有弊，容器技术没有传统虚拟机的独立性那么好</p><table><thead><tr><th>-</th><th>虚拟机</th><th>docker容器</th></tr></thead><tbody><tr><td>操作系统</td><td>宿主机上运行虚拟机OS</td><td>共享宿主机OS</td></tr><tr><td>存储</td><td>镜像较大（GB）</td><td>镜像小（MB）</td></tr><tr><td>性能</td><td>操作系统额外的cpu、内存消耗</td><td>几乎无性能损耗</td></tr><tr><td>移植</td><td>性笨重、与虚拟化技术耦合度高</td><td>轻量、灵活迁移</td></tr><tr><td>隔离性</td><td>完全隔离</td><td>安全隔离</td></tr><tr><td>部署</td><td>慢、分钟级</td><td>快速、秒级</td></tr><tr><td>运行密度</td><td>一般几十个</td><td>单机支持上千容器</td></tr></tbody></table><h2 id="容器如何工作"><a href="#容器如何工作" class="headerlink" title="容器如何工作"></a>容器如何工作</h2><p>容器分为了三部分：1.Client   2.DOCKER_HOST  3.Registry</p><ol><li><p>Client:<br> 主要用来发起指令 dorker build 、docker pull 、 docker run …..</p></li><li><p>DOCKER_HOST</p></li><li><p>Registry</p></li></ol><p>假如我们再Client执行docker run ，Client会把这条指令提交到DOCKER_HOST的Docker daemon（docker服务后端服务端）,Docker daemon 随后会调用本机的docker镜像，从而创建用户所需要的容器，如果本机的docker镜像不存在，docker daemon就会连接Registry，从仓库去下载镜像（当然，可以直接提交从Registry下载镜像的指令） </p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h3><ol><li>docker search</li><li>docker iamges</li><li>docker pull</li><li>docker rmi</li></ol><h3 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h3><ol><li>docker run</li><li>docker ps</li><li>docker rm</li><li>docker start</li><li>docker stop</li><li>docker restart</li><li>docker kill</li></ol><h3 id="其他常用命令图示"><a href="#其他常用命令图示" class="headerlink" title="其他常用命令图示"></a>其他常用命令图示</h3><p><img src="https://s1.ax1x.com/2020/05/18/YWSGbq.png" alt="YWSGbq.png"></p><p>注：当我们以交互的方式进入容器时，想要退出时敲exit即可，但exit是退出并删除容器，我们有些时候需要退出容器却不删除，这时可用Ctrl + P + Q</p><h2 id="Docker精髓"><a href="#Docker精髓" class="headerlink" title="Docker精髓"></a>Docker精髓</h2><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p>我们知道，容器删了，该容器的数据就都没有了，可现实中我们通常需要数据的存储，因为有了需求，希望数据可以持久化，所以就有了容器数据卷</p><p>数据卷挂载分为三种方式</p><ol><li><p>-v<br> （-v 主机目录:容器目录）指定目录挂载</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /home/test:/home centos</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样主机下的/home/<span class="built_in">test</span>就和容器内的/home同步起来了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在容器下的/home新建一个test.txt，返回主机查看，发现多了一个test.txt</span></span><br></pre></td></tr></table></figure><p> （-v 名字:容器目录）具名挂载</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v test:/home centos</span><br></pre></td></tr></table></figure><p> （-v 容器目录）匿名挂载</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /home centos</span><br></pre></td></tr></table></figure></li><li><p>DockerFile的VOLUME来挂载</p><p> dockerfile可以通过docker build来执行，对于DockerFile的使用，下面会讲,这里给个简单的小例子，在/home/test下新建一个dockerfile1,用vim来编辑，以下为内容</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;容器挂载目录&quot;,&quot;容器挂载目录&quot;,&quot;多个的话用逗号隔开&quot;]</span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p> 通过docker build -f /这个dockerfile的目录/dockerfile1 -t name:tag来执行，比如</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /home/test/dockerfile1 -t newCentos:1.0 .    (记住这里有个点，不然会报错)</span><br></pre></td></tr></table></figure><p> build完只是创建了一个image，还要run一下才会进行挂载</p><p> 这种方式挂载的数据卷是匿名挂载，可通过docker inspect查看所挂载的主机目录，一般都是在/var/lib/docker/volmes下</p></li><li><p>–volumes-from<br> –volumes-from的使用，我们看个例子，先执行dockerfile，生成一个test:1.0的centos镜像</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;volumeFolder&quot;]</span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f dockerfile的路径 -t test:1.0 .</span><br></pre></td></tr></table></figure><p> 然后启动一个名为centos1的centos容器，</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name centos1 test:1.0</span><br></pre></td></tr></table></figure><p> ls可以看到有一个已经挂载的目录，叫”volumeFolder“，到这里是我们的第二种的挂载方式</p><p> 我们另外开一个ssh窗口，docker ps可以看到centos1正在运行着，把这个正在运行的容器称为数据卷容器，接下来使用–volume-from进行挂载</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name centos2 --volume-from centos1 test:1.0</span><br></pre></td></tr></table></figure><p> ls查看目录，也能看到目录底下有volumeFolder,你在centos1里往volumeFloder添加的东西，centos2都会同步过来</p><p> 你可以再开一个ssh窗口，在两个容器在进行操作的同时，docker inspect 查看centos1挂载的主机目录，在进行查看变化，可以发现所挂在的磁盘都是互相共享的。</p><p> 除了指定目录挂载，其他的俩种方式，挂在后的数据存放在主机目录的/var/lib/docker/volumes/下，匿名挂载所生成的名字是唯一的，通常我们都会使用具名挂载。此外，我们还可通过docker volume COMMAND COMMAND 查看数据卷的挂载情况</p><p> 通过-v挂载的数据卷，还可以通过inspect的mounted属性查看是否挂载成功（不成功不会显示以下信息）<br> <img src="https://s1.ax1x.com/2020/05/19/Y5Znuq.png" alt="Y5Znuq.png"></p></li></ol><p>到此，以上就是本次学习的三种数据卷的挂载了</p><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>上面也接触到了，其实dockerfile就是一个脚本文件，其核心作用是通过build来执行，生成一个image，步骤分为三步</p><ol><li><p>编写一个dockerfile文件</p></li><li><p>docker build生成一个镜像</p></li><li><p>docker run 执行一个镜像</p></li><li><p>docker pull 发布一个镜像（发布到docker hub或者阿里云镜像仓库）</p></li></ol><h4 id="dockerfile命令"><a href="#dockerfile命令" class="headerlink" title="dockerfile命令"></a>dockerfile命令</h4><p>知道了dockerfile是干嘛的，让我们开始学习以下dockerfile该如何写把，</p><ol><li><p>每个保留关键字必须都是大写字母</p></li><li><p>从上到下的执行顺序</p></li><li><p>#这是注释</p></li><li><p>一行一行的执行，每一行都会生成一个镜像</p></li></ol><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td></tr><tr><td>MAINTAINWE</td><td>指定维修人</td></tr><tr><td>RUN</td><td>要执行的命令</td></tr><tr><td>ADD</td><td>添加其他包</td></tr><tr><td>WORKDIR</td><td>指定工作目录</td></tr><tr><td>VOLUME</td><td>挂载的目录</td></tr><tr><td>EXPOSE</td><td>指定暴露的端口</td></tr><tr><td>CMD</td><td>指定容器启动的时候运行的命令</td></tr><tr><td>ENTRYPOINT</td><td>和CMD一样都是启动后要运行的命令，不同在于CMD是执行最后一个，而ENTRYPOINT是进行追加的方式</td></tr><tr><td>ONBUILD</td><td>当构建一个被继承的DockerFile，这个时候就会触发ONBUILD执行</td></tr><tr><td>COPY</td><td>将主机文件拷贝到镜像中</td></tr><tr><td>ENV</td><td>构建的时候设置环境变量</td></tr></tbody></table><h4 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h4><ol><li><p>docker hub</p><p> 先到dockerhub的官方页面，注册一个账号，然后回到ssh，docker login -u 账户 -p 密码,然后docker push name:tag就行了</p></li><li><p>阿里云镜像仓库</p><p> 登录阿里云，进入容器镜像服务，创建一个命令空间，然后创建一个镜像仓库，创建完阿里云会给教程，按着来就行</p></li></ol><h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker学习笔记&quot;&gt;&lt;a href=&quot;#Docker学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Docker学习笔记&quot;&gt;&lt;/a&gt;Docker学习笔记&lt;/h1&gt;&lt;h2 id=&quot;什么是docker&quot;&gt;&lt;a href=&quot;#什么是docker&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>How to relaxing</title>
    <link href="https://oshino.cc/2020/03/18/how%20to%20relaxing/"/>
    <id>https://oshino.cc/2020/03/18/how%20to%20relaxing/</id>
    <published>2020-03-17T19:23:00.000Z</published>
    <updated>2021-12-16T14:47:43.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-relaxing-is-so-important"><a href="#Why-relaxing-is-so-important" class="headerlink" title="Why relaxing is so important?"></a>Why relaxing is so important<code>?</code></h2><p>最近自我感觉压力是真的大，对应的表现有着：”脑子乱“、“想抛开当前面临的事情”、”食欲不振，伴随而来的体重大幅降低”、”心烦意乱，注意力不集中”等，其他人的表现我倒不清楚。</p><p>不管哪一项，都对我的生活都有着很大的影响，每一天都不变昏昏沉沉的度过已经一两个星期了，许多的事情因此都被我丢在了一旁，上网找了很多如何relaxing的文章，就从这点来讲，你就知道压力有多大了，谁会没事上网找如何放松的文章呢…..呵呵，这次的经历也是头一次感觉放松如此的重要。还有很多事等着我去干呢，时间不等人。</p><p>有了这次抗压能力的up，下次在面对重大压力的时候，自己也许能够更加稳重的处理，这也是人生的一部分吧？<strong>呵呵</strong></p><h2 id="How-to-relaxing"><a href="#How-to-relaxing" class="headerlink" title="How to relaxing?"></a>How to relaxing<code>?</code></h2><p>怎么放松呢？或者说如何让压力满满，回归到积极向上的一面呢？我自己有着以下几点方法</p><ol><li><p>深呼吸</p></li><li><p>听一些曲调起伏不大的纯音乐</p></li><li><p>做点自己喜欢的事情</p></li><li><p>拥抱大自然</p></li><li><p>吧经历和压力的来源记录下来</p></li><li><p>定制一下to do list，然后完成它！</p></li></ol><p>不得不说，深呼吸是有用的，在写这篇文章的时候，已经两天没睡觉了，闭上眼想睡觉的时候，脑子时不时会浮现出自己拿着手机或者其他东西可以扔的东西，用尽自己的力气往角落里扔，同时还有很多人睁大眼睛朝我yelling的画面，而且切换的速度特别快，大概1s就切换了好几十个人了，不知道是不是心理出了问题，这是有暴力倾向吗？唉，每当这时候，睁开眼，看着昏暗的天花板进行深呼吸，那些画面就都没了。</p><p>听音乐真的超级有效，前提是你喜欢听音乐？因为我个人喜欢听音乐，在非看视频的情况下，我的播放器都是时刻在播放的，在此次经历之前，我一有不开心，或者独处，亦或是放松，都是听音乐过来的，然后睡个觉啥压力都没了，spotify有ChilledCow的歌单，一个学习，一个睡觉，两个都很推荐，不过放松的话，还是推荐睡觉的歌单——lofi hip hop music-beats to sleep/chill to，没玩spotify的也可以上404观看，ChilledCow好像是24小时直播？反正我每次上次都看到ChilledCow在直播放着音乐。<strong>把周围的环境整理好，躺在床上，戴上耳机，闭眼细听着音乐，so ralaxing</strong></p><p>做点自己喜欢的事情，我的话打打游戏，KTV大吼大叫，和朋友出去滑滑板，叫他们出来吹吹水喝喝酒，都行，抛开你面临的事情，做你想做的事情</p><p>拥抱大自然，这点真的让我很放松，去到海边，就坐在岸边，看着海浪拍打在沙滩上，或者深山野林，找块石头坐着，听着大自然发出来的声音，这都是能让我一待就是几个小时的场景，事后整个人都会很舒服</p><p>由于隐私问题，把经历记录下来或许很难？因人而异吧，我的话就像我现在这样，把自己对放松的理解整理后写下来，过程中自己也会去想，把自己置入一种身临其境的感觉，来让自己放松放松，其实把你压力来源整理出来，真的有益于你处理压力，从而达到释放压力的效果，这点和抑郁患者的治疗是差不多的，我记得他们是把抑郁的情绪来源记录下来？让自己明白自己为什么会这样，连来源都不知道，你说怎么对症下药，对吧?</p><p>以上都能让我的身心放松，最后一点是在这基础上，让自己已被打乱的生活能更快的进入正轨，没耐心去执行？尝试一下把，长时间坚持下来真的对你生活有很大的帮助。</p><h2 id="有感而发"><a href="#有感而发" class="headerlink" title="有感而发"></a>有感而发</h2><p>现在年轻人的压力是真的大，家庭，学业，社交各方面都有，各方面都担当着不同的角色，同时各方面都能变得很复杂，经历不同对这句话也许看法也不同把。这么多角色，只要一个做不好，随着而来的是单方面的职责，’不孝顺’、’学习不好’、’老是宅着不社交’、’不负责’等等，</p><p>很多人在压力很大的时候，都会有这样的想法，”要是自己是小孩子就好了“、“小孩子没有压力真好”啥的，我也想过，你没想过当然是好，这里只是我的有感而发。</p><p><strong>小孩子没有压力?</strong></p><p>其实并不是这样，只是小孩子并不能察觉到气氛，同时大人在小孩子面前也会减少不必要的行为给小孩子营造负气氛。随着长大，大人逐渐在你面前谈论一些以前没听过的话题，你也逐渐学会看懂气氛，家庭的压力随之而来，前提是前面谈及都是与你有关，与你无关当然不会有所谓的压力。当然很多时候更多的时候间接压力，于成年人面对的直接压力是不一样的，说起来复杂，打住。</p><p>那些早熟的孩子，哪一个不是有过非一般的经历——校园暴力、家庭暴力、恋童癖受害者、性暴力等等，这些经历都会让孩子学会看懂气氛，在察觉到气氛后，做出和别人不同的决定，什么？你说你认识其他早熟的孩子没有经历过这些，确实有不少小孩子、年轻人在看了日漫或者许多流媒体后，在“云体验”不同的故事过后思想变得成熟，这种成熟在和那些真正经历过的人，最终做的决定，我相信是不一样的，<strong>云体验终究是云体验</strong>，当然我也不想一棒子打死，有个例是不一样的，这里我只对比例进行总结，个例是不能反驳比例的。</p><p>最近这几样东西老是围绕着我，我也不在是小孩子，以前没想到的，最近都会静下来好好思考，随着思考不断深入，引申出很多内容，比如真的要好好学习提高学历，提高学历是为了让你见识零一层次的人，同时能到处走走就尽量到处走走把，或许我之后会为了旅行而工作也不一定。每次我们在思考完，老想着找个地方倾述，朋友圈，网易云各种社交类软件，但我想你应该和我有过一样的想法把，就是自己和他们聊不来，发出去也没人懂，如对牛弹琴，我自己不喜欢自己呕心沥血写的东西被人鸟都不鸟的略过，我也是刚刚才想起来我有博客来写，不过写在博客也没人看，真是奇怪的想法，或者我就是想记录下来，写到这里我感觉我的思路已经很乱了，文章都在乱写，想到啥写啥，或许在过阵子来看的话，会觉得很羞耻很搞笑也不一定？呵,就先这样把。</p><p><strong>加油!</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Why-relaxing-is-so-important&quot;&gt;&lt;a href=&quot;#Why-relaxing-is-so-important&quot; class=&quot;headerlink&quot; title=&quot;Why relaxing is so important?&quot;&gt;&lt;/a&gt;W</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2020计划</title>
    <link href="https://oshino.cc/2020/01/02/2020%E8%AE%A1%E5%88%92/"/>
    <id>https://oshino.cc/2020/01/02/2020%E8%AE%A1%E5%88%92/</id>
    <published>2020-01-02T08:37:28.000Z</published>
    <updated>2021-12-16T14:43:10.881Z</updated>
    
    <content type="html"><![CDATA[<p>今天1月11号了，前两天就回家了，这会才缓过来已经2020了，早上睡醒后刷一刷b站，看到了何同学的总结，让我想起了19年初和前女友写的计划，想过来唠嗑一下，顺便立下新一年的flag。</p><p>一年过去，自己已成独行侠，但19年还是值得回顾的，爬山、学习、放松、穷游、比赛等等，立下的计划基本都完成的差不多了，夸自己一下，真棒。</p><h2 id="增加学习量"><a href="#增加学习量" class="headerlink" title="增加学习量"></a>增加学习量</h2><p>让我惊讶的是，我意识到这一年学习能力提高很多，学习计划我在年初定下的时候，还怕自己学习不来而专门减少了些，但基本都完成了，其中还划水了很多时间，特别是年末，去年那些学习计划在我现在看来也就需要几个月的时间。</p><h2 id="增加锻炼"><a href="#增加锻炼" class="headerlink" title="增加锻炼"></a>增加锻炼</h2><p>对新知识的渴望也是我所惊讶的，一接触到新技术，我就特别想去学，通宵不吃饭，学习的过程中一点时间都不想浪费，也让我更加确定自己想干IT方面的活。不过这也导致身体能力每况愈下，有之前的锻炼打底，身体没那么糟糕，但自己的身体自己清楚，我还是知道抵抗力啥的在下降。今年要多加锻炼！！</p><h2 id="增加抗压能力"><a href="#增加抗压能力" class="headerlink" title="增加抗压能力"></a>增加抗压能力</h2><p>讲真，舆论啥的我根本没在怕，看透很多以为自己抗压能力很不错，但我还是小看了人生。下半年参加两个比赛，都因为没上榜而心情低落，自己正真用心了的努力得不到认可就是这种心情吧，表面笑嘻嘻，半夜人间不值得，经常这样导致学习效率低下，两个比赛失败过来，自己已经慢慢适应了，之后再出现落榜了的话，希望自己能抗住，把悲愤化为力量！！</p><h2 id="接触新媒体"><a href="#接触新媒体" class="headerlink" title="接触新媒体"></a>接触新媒体</h2><p>经常看vlog，偶尔会想vlog和blog的区别，两者载体不一样，但本质都是“记录”，但今年我想尝试用视频的方式的来记录一下日常、工作室学习之类的，所以今年的计划里，有一个拍vlog，至于设备，用手机或者借用一下工作室的相机吧，我很期待自己的vlog！！</p><h2 id="什么才是matrue"><a href="#什么才是matrue" class="headerlink" title="什么才是matrue"></a>什么才是matrue</h2><p>19年的计划里，有这么一个“再懂事点”的计划，一年过了我也不知道现在自己这样算不算懂事，但我不满意。在我看来，年龄的增加、外表的成熟，不一定人就成熟，我自己也不知道怎么定义成熟，但起码是懂事的，懂得一些人情世故，懂得读取气氛，做得出选泽的，过去的几年里，家里的火苗终于在去年变越变越大，今年也许会继续烧下去，或将在这2020年终结，我也在去年意识到，大人们已经不把我看成小孩了。反正现在的我还不够，继续在新的一年成长。</p><h2 id="关心人际"><a href="#关心人际" class="headerlink" title="关心人际"></a>关心人际</h2><p>去年或许是我最“事不关己高高挂起”的一年了，除了学习什么都不想管，也因为这个和前女友分手了，上半年疯狂学，下半年也没差，在下半年意识到自己似乎有些过分，在和朋友出去吃饭，或者正常的人际交往中，总是很随和，之前都是很有主见的人的=-=。今年除了关心人际，还要多照顾自己的想法！</p><h2 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h2><p>这点就不多说了，说多就是泪，理财就是对！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在便签会记录自己的计划，顺便贴出来吧。</p><p><img src="https://s2.ax1x.com/2020/01/11/lIkMLV.jpg" alt="lIkMLV.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天1月11号了，前两天就回家了，这会才缓过来已经2020了，早上睡醒后刷一刷b站，看到了何同学的总结，让我想起了19年初和前女友写的计划，想过来唠嗑一下，顺便立下新一年的flag。&lt;/p&gt;
&lt;p&gt;一年过去，自己已成独行侠，但19年还是值得回顾的，爬山、学习、放松、穷游、比</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>昨日份壁纸分享</title>
    <link href="https://oshino.cc/2019/12/18/Let&#39;s%20All%20Love%20Lain/"/>
    <id>https://oshino.cc/2019/12/18/Let&#39;s%20All%20Love%20Lain/</id>
    <published>2019-12-18T15:23:00.000Z</published>
    <updated>2021-12-16T14:50:31.357Z</updated>
    
    <content type="html"><![CDATA[<p>前两天补了个老番叫Lain,已经成为我心中的一部神作了</p><p>看了这么多番，主角的人物塑造能让人在事后印象深刻的，在这之前只有我Ryougi Shiki,现在又多了Lain</p><p>太棒了这个番，看完我就迫不及待的去搜壁纸了，现在PC/手机壁纸都是Lain,分享一下PC端的壁纸</p><h2 id="Let’s-All-Love-Lain"><a href="#Let’s-All-Love-Lain" class="headerlink" title="Let’s All Love Lain ! ! !"></a>Let’s All Love Lain ! ! !</h2><p><img src="https://s2.ax1x.com/2020/02/21/3mftUI.png" alt="3mftUI.png"></p><p><img src="https://s2.ax1x.com/2020/02/21/3mfaPP.jpg" alt="3mfaPP.jpg"></p><p><img src="https://s2.ax1x.com/2020/02/21/3mfd8f.png" alt="3mfd8f.png"></p><p><img src="https://s2.ax1x.com/2020/02/21/3mf0xS.png" alt="3mf0xS.png"></p><p><img src="https://s2.ax1x.com/2020/02/21/3mfDKg.png" alt="3mfDKg.png"></p><p><img src="https://s2.ax1x.com/2020/02/21/3mfrrQ.png" alt="3mfrrQ.png"></p><p><img src="https://s2.ax1x.com/2020/02/21/3mf6Vs.png" alt="3mf6Vs.png"></p><p><img src="https://s2.ax1x.com/2020/02/21/3mfRP0.png" alt="3mfRP0.png"></p><p><img src="https://s2.ax1x.com/2020/02/21/3mfWGV.jpg" alt="3mfWGV.jpg"></p><p><img src="https://s2.ax1x.com/2020/02/21/3mf5MF.png" alt="3mf5MF.png"></p><p><img src="https://s2.ax1x.com/2020/02/21/3mfIr4.png" alt="3mfIr4.png"></p><h2 id="图片来源"><a href="#图片来源" class="headerlink" title="图片来源"></a>图片来源</h2><p><a href="https://wall.alphacoders.com/">Wall Alphacoders</a></p><p><a href="https://fauux.neocities.org/">W i r e d   S o u n d</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前两天补了个老番叫Lain,已经成为我心中的一部神作了&lt;/p&gt;
&lt;p&gt;看了这么多番，主角的人物塑造能让人在事后印象深刻的，在这之前只有我Ryougi Shiki,现在又多了Lain&lt;/p&gt;
&lt;p&gt;太棒了这个番，看完我就迫不及待的去搜壁纸了，现在PC/手机壁纸都是Lain,分</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>最近可好</title>
    <link href="https://oshino.cc/2019/11/22/%E6%9C%80%E8%BF%91%E5%8F%AF%E5%A5%BD/"/>
    <id>https://oshino.cc/2019/11/22/%E6%9C%80%E8%BF%91%E5%8F%AF%E5%A5%BD/</id>
    <published>2019-11-22T08:37:28.000Z</published>
    <updated>2021-12-16T14:49:46.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最近可好"><a href="#最近可好" class="headerlink" title="最近可好"></a>最近可好</h1><p>通宵搞得的wordpress也差不多了，还差个域名解析，可能的话后面再对主题进行一定的DIY，但很遗憾的讲由于之前的wordpress没有备份就臭手删掉了/root上的env.txt(我用的是阿里云的wordpress镜像)，导致忘记了密码，且不知什么原因blog访问不了，最后选择了重置wordpress镜像，导致我一年来写的博客数据都没有了，我这个傻子，原来也没有保存一手md文件，算是得了个教训，现在写文章会直接创建md文件进行手写，然后再atl+A copy到wordpress的编辑器再进行发布，就像我现在这样。</p><p>从去年的12月中旬开始搞， 到现在博客也快一年啦，回顾自己所学习的，发现自己学的并不是很多，反而在这里发了很多牢骚 (保持心情舒畅是很关键的！)，最近在学vue.js,基础已经先学完了，也学完Vue-Router，打算写点小项目练练手，后面再把vue的其他扩张知识一起给学习了，Vuex，axios等</p><p>在这立个flag</p><hr><p>未来让自己逐渐走向全栈！</p><hr><p>顺便分享一下棉花糖的新歌Tongue Tied，好听！</p><p>以上！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最近可好&quot;&gt;&lt;a href=&quot;#最近可好&quot; class=&quot;headerlink&quot; title=&quot;最近可好&quot;&gt;&lt;/a&gt;最近可好&lt;/h1&gt;&lt;p&gt;通宵搞得的wordpress也差不多了，还差个域名解析，可能的话后面再对主题进行一定的DIY，但很遗憾的讲由于之前的word</summary>
      
    
    
    
    
  </entry>
  
</feed>
